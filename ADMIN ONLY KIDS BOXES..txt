ADMIN ONLY KIDS BOXES.

'use client';

import React, { useCallback, useEffect, useMemo, useState } from 'react';

/**
 * Kids Admin — Phone-first (all revisions)
 * - Separate route at /admin (landing boxes unchanged)
 * - Up to 5 local kids (delete, Auto/Manual + autoAction, IP/port/phones) — stored locally
 * - Active Kid chips; auto-select into Task Creator/Enforce if enabled
 * - Plan auto-lock (optional GET /api/plan), otherwise manual select (Free=1, Lite=2, Elite=∞)
 * - Header: Home + Reload
 * - Template: fillable input with suggestion list; auto-fills Title
 * - Acting user (who sends API calls) + “Acting name” (fillable, remembered) synced to Kid name
 * - Kid Phone preview (status + comment + local manual tasks), Owner preview (quick comments + note)
 * - Uses existing backend endpoints only; preview notes are localStorage-only
 */

const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://127.0.0.1:4000';

/* ----------------------------- Helpers ----------------------------- */
async function fetchJSON<T>(input: RequestInfo | URL, init?: RequestInit): Promise<T> {
  const res = await fetch(input, init);
  if (!res.ok) {
    const text = await res.text().catch(() => '');
    throw new Error(text || `HTTP ${res.status}`);
  }
  return (await res.json()) as T;
}
function cls(...a: Array<string | false | undefined>) {
  return a.filter(Boolean).join(' ');
}
function parseTimeHHMM(s: string) {
  const m = s.match(/^(\d{1,2}):(\d{2})$/);
  if (!m) return { h: 8, m: 0 };
  return {
    h: Math.min(23, Math.max(0, parseInt(m[1], 10))),
    m: Math.min(59, Math.max(0, parseInt(m[2], 10))),
  };
}
function nextAtDaily(hour: number, minute: number) {
  const now = new Date();
  const d = new Date();
  d.setHours(hour, minute, 0, 0);
  if (d.getTime() <= now.getTime()) d.setDate(d.getDate() + 1);
  return d.getTime();
}
function nextAtWeekly(dow: number, hour: number, minute: number) {
  const now = new Date();
  const d = new Date();
  d.setHours(hour, minute, 0, 0);
  const delta = (dow - d.getDay() + 7) % 7;
  if (delta === 0 && d.getTime() <= now.getTime()) d.setDate(d.getDate() + 7);
  else d.setDate(d.getDate() + delta);
  return d.getTime();
}

/* ----------------------------- Types ----------------------------- */
type Role = 'Owner' | 'Family' | 'Child' | 'Minor' | 'Caregiver' | 'Relative';

type User = { id: string; name: string; role: Role };

type Task = {
  id: string;
  title: string;
  circleId: string;
  assignedTo?: string;
  due?: number;
  completed?: boolean;
  proofKey?: string;
  forMinor?: boolean;
  ackRequired?: boolean;
  photoProof?: boolean;
  ackAt?: number;
  ackBy?: string;
  __minorStage?: 0 | 1 | 2 | 3 | 4;
  repeat?: 'none' | 'daily' | 'weekly';
  autoEnforce?: boolean;
  autoAction?:
    | 'screen_lock'
    | 'network_pause'
    | 'device_restart'
    | 'device_shutdown'
    | 'app_restart'
    | 'play_loud_alert';
};

type PlanKey = 'free' | 'lite' | 'elite';
const PLAN_LIMITS: Record<PlanKey, number> = { free: 1, lite: 2, elite: 999 };

type ActionV =
  | 'play_loud_alert'
  | 'screen_lock'
  | 'network_pause'
  | 'device_restart'
  | 'device_shutdown'
  | 'app_restart';

type LocalKid = {
  id: string;
  name: string;
  apiUserId?: string;
  ip?: string;
  port?: number;
  phones?: string[];
  notes?: string;
  autoEnforce?: boolean;
  autoAction?: ActionV;
};

type KidStatus = 'not_started' | 'in_progress' | 'almost_done' | 'done' | 'skipped';

/* ------------------------ Local Storage Keys ------------------------ */
const LSK_KIDS = 'admin.localKids.v2';
const LSK_OWNER = 'admin.ownerLabel.v1';
const LSK_PLAN = 'admin.plan.v1';
const LSK_TASK_NOTES = 'admin.taskNotes.v1'; // { [taskId]: { status, comment } }
const LSK_OWNER_NOTES = 'admin.ownerNotes.v1'; // { [taskId]: { preset, comment } }
const LSK_LOCAL_PHONE_TASKS = 'admin.localPhoneTasks.v1'; // { [kidLocalId]: Array<{id,title,due?}> }
const LSK_NAME_BOOK = 'admin.nameBook.v1'; // string[] of remembered names

/* ---------------------------- Constants ---------------------------- */
const TEMPLATES = [
  'Clean room',
  'Wash dishes',
  'Take out trash',
  'Homework',
  'Laundry',
  'Feed pets',
  'Read 20 minutes',
  'Practice instrument',
] as const;

const ACTIONS: ReadonlyArray<{ v: ActionV; label: string }> = [
  { v: 'play_loud_alert', label: 'Loud alert' },
  { v: 'screen_lock', label: 'Lock screen' },
  { v: 'network_pause', label: 'Pause network' },
  { v: 'device_restart', label: 'Restart device' },
  { v: 'device_shutdown', label: 'Shutdown device' },
  { v: 'app_restart', label: 'Restart app' },
];

/* ============================ Component ============================ */
export default function AdminPage() {
  /* -------- Acting user (who sends API calls) -------- */
  const [acting, setActing] = useState<string>('u-owner');
  const headers = useMemo(() => ({ 'x-user-id': acting }), [acting]);

  /* -------- API data -------- */
  const [users, setUsers] = useState<User[]>([]);
  const [tasks, setTasks] = useState<Task[]>([]);
  const childUsers = users.filter((u) => u.role === 'Child' || u.role === 'Minor');

  /* -------- Owner/household label -------- */
  const [ownerLabel, setOwnerLabel] = useState<string>('');

  /* -------- Plan gating -------- */
  const [plan, setPlan] = useState<PlanKey>('elite');
  const maxKids = PLAN_LIMITS[plan];

  /* -------- Local kids / previews / memory -------- */
  const [kids, setKids] = useState<LocalKid[]>([]);
  const [activeKidId, setActiveKidId] = useState<string | null>(null);
  const [autoSelectActive, setAutoSelectActive] = useState<boolean>(true);

  const [taskNotes, setTaskNotes] = useState<Record<string, { status: KidStatus; comment?: string }>>({});
  const [ownerNotes, setOwnerNotes] = useState<Record<string, { preset?: string; comment?: string }>>({});
  const [phoneTasks, setPhoneTasks] = useState<Record<string, Array<{ id: string; title: string; due?: number }>>>({});
  const [nameBook, setNameBook] = useState<string[]>([]);
  const [actingName, setActingName] = useState<string>('');

  useEffect(() => {
    try {
      const rk = typeof window !== 'undefined' ? localStorage.getItem(LSK_KIDS) : null;
      if (rk) setKids(JSON.parse(rk) as LocalKid[]);
      const ro = typeof window !== 'undefined' ? localStorage.getItem(LSK_OWNER) : null;
      if (ro) setOwnerLabel(ro);
      const rp = (typeof window !== 'undefined' ? localStorage.getItem(LSK_PLAN) : null) as PlanKey | null;
      if (rp) setPlan(rp);
      const rn = typeof window !== 'undefined' ? localStorage.getItem(LSK_TASK_NOTES) : null;
      if (rn) setTaskNotes(JSON.parse(rn));
      const ron = typeof window !== 'undefined' ? localStorage.getItem(LSK_OWNER_NOTES) : null;
      if (ron) setOwnerNotes(JSON.parse(ron));
      const rph = typeof window !== 'undefined' ? localStorage.getItem(LSK_LOCAL_PHONE_TASKS) : null;
      if (rph) setPhoneTasks(JSON.parse(rph));
      const rnb = typeof window !== 'undefined' ? localStorage.getItem(LSK_NAME_BOOK) : null;
      if (rnb) setNameBook(JSON.parse(rnb));
    } catch {
      /* ignore */
    }
  }, []);

  const persistKids = useCallback((next: LocalKid[]) => {
    setKids(next);
    try {
      localStorage.setItem(LSK_KIDS, JSON.stringify(next));
    } catch {}
  }, []);
  const persistOwner = useCallback((label: string) => {
    setOwnerLabel(label);
    try {
      localStorage.setItem(LSK_OWNER, label);
    } catch {}
  }, []);
  const persistPlan = useCallback((p: PlanKey) => {
    setPlan(p);
    try {
      localStorage.setItem(LSK_PLAN, p);
    } catch {}
  }, []);
  const persistTaskNotes = useCallback(
    (next: typeof taskNotes) => {
      setTaskNotes(next);
      try {
        localStorage.setItem(LSK_TASK_NOTES, JSON.stringify(next));
      } catch {}
    },
    [taskNotes],
  );
  const persistOwnerNotes = useCallback(
    (next: typeof ownerNotes) => {
      setOwnerNotes(next);
      try {
        localStorage.setItem(LSK_OWNER_NOTES, JSON.stringify(next));
      } catch {}
    },
    [ownerNotes],
  );
  const persistPhoneTasks = useCallback(
    (next: typeof phoneTasks) => {
      setPhoneTasks(next);
      try {
        localStorage.setItem(LSK_LOCAL_PHONE_TASKS, JSON.stringify(next));
      } catch {}
    },
    [phoneTasks],
  );

  /* -------- Task creation state -------- */
  const [template, setTemplate] = useState<string>('');
  const [title, setTitle] = useState<string>('Clean room');
  const [recurrence, setRecurrence] = useState<'none' | 'daily' | 'weekly'>('none');
  const [dueMins, setDueMins] = useState<number>(15);
  const [weeklyDOW, setWeeklyDOW] = useState<number>(1);
  const [timeHHMM, setTimeHHMM] = useState<string>('08:00');
  const [ackRequired, setAckRequired] = useState<boolean>(true);
  const [photoProof, setPhotoProof] = useState<boolean>(true);
  const [selectedKidIds, setSelectedKidIds] = useState<string[]>([]);
  const [autoAction, setAutoAction] = useState<ActionV>('screen_lock');
  const [autoEnforce, setAutoEnforce] = useState<boolean>(true);
  const [busy, setBusy] = useState<boolean>(false);
  const [err, setErr] = useState<string>('');

  /* -------- Auto select the active kid -------- */
  useEffect(() => {
    if (autoSelectActive && activeKidId) setSelectedKidIds([activeKidId]);
  }, [autoSelectActive, activeKidId]);

  const resetForm = useCallback(() => {
    setTemplate('');
    setTitle('Clean room');
    setRecurrence('none');
    setDueMins(15);
    setWeeklyDOW(1);
    setTimeHHMM('08:00');
    setAckRequired(true);
    setPhotoProof(true);
    setSelectedKidIds([]);
    setAutoAction('screen_lock');
    setAutoEnforce(true);
  }, []);

  const toggleKid = useCallback(
    (id: string) => {
      if (autoSelectActive) {
        setActiveKidId(id);
        return;
      }
      setSelectedKidIds((prev) => {
        if (prev.includes(id)) return prev.filter((x) => x !== id);
        if (prev.length >= maxKids) {
          alert(`Your plan (${plan}) allows up to ${maxKids === 999 ? 'unlimited' : maxKids} child${maxKids > 1 ? 'ren' : ''}.`);
          return prev;
        }
        return [...prev, id];
      });
    },
    [autoSelectActive, maxKids, plan],
  );

  /* -------- Load API data -------- */
  const loadAll = useCallback(async () => {
    setErr('');
    try {
      const [u, t] = await Promise.all([
        fetchJSON<User[]>(`${API_BASE}/api/users`, { headers }),
        fetchJSON<Task[]>(`${API_BASE}/api/tasks`, { headers }),
      ]);
      setUsers(u);
      setTasks(t);
    } catch (e) {
      setErr((e as Error).message || 'Load failed');
    }
  }, [headers]);

  useEffect(() => {
    void loadAll();
  }, [acting, loadAll]);

  /* -------- Plan auto-lock from API (optional) -------- */
  useEffect(() => {
    (async () => {
      try {
        const res = await fetchJSON<{ plan: PlanKey }>(`${API_BASE}/api/plan`, { headers });
        if (res?.plan && (['free', 'lite', 'elite'] as PlanKey[]).includes(res.plan)) {
          persistPlan(res.plan);
        }
      } catch {
        /* ignore if not available */
      }
    })();
  }, [headers, persistPlan]);

  /* -------- Create minor tasks -------- */
  const createMinorTasks = useCallback(async () => {
    if (!title.trim()) {
      alert('Title is required.');
      return;
    }
    const useIds = autoSelectActive && activeKidId ? [activeKidId] : selectedKidIds;
    if (useIds.length === 0) {
      alert('Select at least one child.');
      return;
    }

    const apiChildren = users.filter((u) => u.role === 'Child' || u.role === 'Minor');
    if (apiChildren.length === 0) {
      alert("No API 'Child' users found. Add at least one child user to the circle first.");
      return;
    }

    setBusy(true);
    setErr('');
    try {
      const defaultChildId = apiChildren[0]?.id;
      const { h, m } = parseTimeHHMM(timeHHMM);
      const requests: Array<Promise<unknown>> = [];

      for (const localId of useIds) {
        const kid = kids.find((k) => k.id === localId);
        const apiUserId = kid?.apiUserId || defaultChildId;
        if (!apiUserId) continue;

        let due: number;
        if (recurrence === 'none') due = Date.now() + Math.max(1, dueMins) * 60_000;
        else if (recurrence === 'daily') due = nextAtDaily(h, m);
        else due = nextAtWeekly(weeklyDOW, h, m);

        requests.push(
          fetchJSON(`${API_BASE}/api/tasks`, {
            method: 'POST',
            headers: { ...headers, 'Content-Type': 'application/json' },
            body: JSON.stringify({
              title,
              due,
              assignedTo: apiUserId,
              forMinor: true,
              ackRequired,
              photoProof,
              repeat: recurrence,
              autoEnforce: kid?.autoEnforce ?? autoEnforce,
              autoAction: (kid?.autoAction as Task['autoAction']) ?? autoAction,
            }),
          }),
        );
      }
      await Promise.all(requests);
      alert(`Created ${useIds.length} task(s) ✅`);
      await loadAll();
      resetForm();
    } catch (e) {
      setErr((e as Error).message || 'Create failed');
      alert(`Create failed: ${(e as Error).message}`);
    } finally {
      setBusy(false);
    }
  }, [
    ackRequired,
    autoAction,
    autoEnforce,
    dueMins,
    headers,
    kids,
    loadAll,
    recurrence,
    resetForm,
    selectedKidIds,
    timeHHMM,
    title,
    users,
    weeklyDOW,
    autoSelectActive,
    activeKidId,
  ]);

  /* -------- ACK -------- */
  const ackTask = useCallback(
    async (id: string) => {
      setErr('');
      try {
        await fetchJSON(`${API_BASE}/api/tasks/${id}/ack`, { method: 'POST', headers });
        await loadAll();
      } catch (e) {
        setErr((e as Error).message || 'ACK failed');
        alert(`ACK failed: ${(e as Error).message}`);
      }
    },
    [headers, loadAll],
  );

  /* -------- Enforce -------- */
  const enforce = useCallback(
    async (apiUserId: string, action: ActionV, reason: string) => {
      setErr('');
      try {
        await fetchJSON(`${API_BASE}/api/parental/enforce`, {
          method: 'POST',
          headers: { ...headers, 'Content-Type': 'application/json' },
          body: JSON.stringify({ targetUserId: apiUserId, action, reason }),
        });
        alert(`Enforce sent: ${action} ✅`);
      } catch (e) {
        setErr((e as Error).message || 'Enforce failed');
        alert(`Enforce failed: ${(e as Error).message}`);
      }
    },
    [headers],
  );

  /* -------- Kids helpers -------- */
  const addKid = useCallback(() => {
    if (kids.length >= 5) {
      alert('You can keep up to 5 local kids.');
      return;
    }
    const id = `k-${Math.random().toString(36).slice(2, 8)}`;
    const next: LocalKid[] = [...kids, { id, name: 'New child', phones: [] }];
    persistKids(next);
    setActiveKidId(id);
    if (autoSelectActive) setSelectedKidIds([id]);
  }, [kids, persistKids, autoSelectActive]);

  const removeKid = useCallback(
    (id: string) => {
      const next = kids.filter((k) => k.id !== id);
      persistKids(next);
      setSelectedKidIds((prev) => prev.filter((x) => x !== id));
      if (activeKidId === id) setActiveKidId(next[0]?.id ?? null);
    },
    [kids, persistKids, activeKidId],
  );

  const updateKid = useCallback(
    (id: string, patch: Partial<LocalKid>) => {
      persistKids(kids.map((k) => (k.id === id ? { ...k, ...patch } : k)));
    },
    [kids, persistKids],
  );

  const updateKidPhone = useCallback(
    (id: string, idx: number, value: string) => {
      const kid = kids.find((k) => k.id === id);
      const phones = (kid?.phones || []).slice();
      phones[idx] = value;
      updateKid(id, { phones });
    },
    [kids, updateKid],
  );

  const addKidPhone = useCallback(
    (id: string) => {
      const kid = kids.find((k) => k.id === id);
      const phones = (kid?.phones || []).slice();
      if (phones.length >= 5) return;
      phones.push('');
      updateKid(id, { phones });
    },
    [kids, updateKid],
  );

  const removeKidPhone = useCallback(
    (id: string, idx: number) => {
      const kid = kids.find((k) => k.id === id);
      const phones = (kid?.phones || []).slice();
      phones.splice(idx, 1);
      updateKid(id, { phones });
    },
    [kids, updateKid],
  );

  /* ------------------------------ UI ------------------------------ */
  return (
    <div className="min-h-dvh space-y-6 p-4 md:p-6">
      {/* Header */}
      <header className="flex items-center justify-between gap-2">
        <div className="flex items-center gap-2">
          <h1 className="text-xl md:text-2xl font-semibold">Kids Admin</h1>
          <div className="hidden sm:flex items-center gap-2">
            <span className="text-xs text-gray-600">Household</span>
            <input
              className="rounded border px-2 py-1 text-sm"
              placeholder="e.g. Mom & Dad"
              value={ownerLabel}
              onChange={(e) => persistOwner(e.target.value)}
            />
          </div>
        </div>
        <div className="flex items-center gap-2">
          <button className="rounded border px-2 py-1 text-sm" onClick={() => (window.location.href = '/')}>
            Home
          </button>
          <button className="rounded border px-2 py-1 text-sm" onClick={() => window.location.reload()}>
            Reload
          </button>
        </div>
      </header>

      {/* Acting + Refresh + Acting name (memory) */}
      <div className="flex flex-wrap items-center gap-2">
        <span className="text-xs text-gray-600">Acting</span>
        <select
          className="rounded border px-2 py-1 text-sm"
          value={acting}
          onChange={(e) => {
            const id = e.target.value;
            setActing(id);
            const sel =
              users.find((u) => u.id === id) ||
              (id === 'u-owner' ? { name: 'Owner' } : id === 'u-child' ? { name: 'Derek' } : id === 'u-fam' ? { name: 'Ryan' } : null);
            const label = sel?.name || '';
            if (label) {
              setActingName(label);
              const tgt = activeKidId || kids[0]?.id;
              if (tgt) {
                updateKid(tgt, { name: label });
                setActiveKidId(tgt);
              }
              if (label && !nameBook.includes(label)) {
                const next = [...nameBook, label];
                setNameBook(next);
                try {
                  localStorage.setItem(LSK_NAME_BOOK, JSON.stringify(next));
                } catch {}
              }
            }
          }}
        >
          {users.map((u) => (
            <option key={u.id} value={u.id}>
              {u.name} ({u.role})
            </option>
          ))}
          {users.length === 0 && (
            <>
              <option value="u-owner">Owner (Owner)</option>
              <option value="u-child">Derek (Child)</option>
              <option value="u-fam">Ryan (Family)</option>
            </>
          )}
        </select>
        <button className="rounded border px-2 py-1 text-sm" onClick={() => void loadAll()}>
          Refresh Data
        </button>

        <label className="flex items-center gap-2 text-sm">
          <span>Acting name</span>
          <input
            className="rounded border px-2 py-1 text-sm"
            list="name-book"
            value={actingName}
            onChange={(e) => {
              setActingName(e.target.value);
              const tgt = activeKidId || kids[0]?.id;
              if (tgt) {
                updateKid(tgt, { name: e.target.value });
                setActiveKidId(tgt);
              }
            }}
            placeholder="type a name"
          />
          <datalist id="name-book">{nameBook.map((n) => <option key={n} value={n} />)}</datalist>
          <button
            className="rounded border px-2 py-1 text-sm"
            onClick={() => {
              if (actingName && !nameBook.includes(actingName)) {
                const next = [...nameBook, actingName];
                setNameBook(next);
                try {
                  localStorage.setItem(LSK_NAME_BOOK, JSON.stringify(next));
                } catch {}
              }
            }}
          >
            Save
          </button>
        </label>
      </div>

      {err && <div className="rounded border border-red-300 bg-red-50 px-3 py-2 text-sm text-red-700">{err}</div>}

      {/* Plan gating */}
      <section className="grid gap-2 rounded border p-3">
        <div className="flex flex-wrap items-center gap-2">
          <span className="text-sm text-gray-600">Plan</span>
          <select className="rounded border px-2 py-1 text-sm" value={plan} onChange={(e) => persistPlan(e.target.value as PlanKey)}>
            <option value="free">Free (1 child)</option>
            <option value="lite">Lite (2 children)</option>
            <option value="elite">Elite (unlimited)</option>
          </select>
          <span className="text-xs text-gray-500">Max selected: {maxKids === 999 ? '∞' : maxKids}</span>
          <label className="ml-auto flex items-center gap-2 text-xs">
            <input type="checkbox" checked={autoSelectActive} onChange={(e) => setAutoSelectActive(e.target.checked)} />
            Auto-select active kid
          </label>
        </div>
      </section>

      {/* Kids list */}
      <section className="grid gap-3 rounded border p-3">
        <div className="flex items-center justify-between">
          <h2 className="font-medium">Kids (local, max 5)</h2>
          <button className="rounded border px-3 py-1 text-sm" onClick={addKid} disabled={kids.length >= 5}>
            Add child
          </button>
        </div>

        <div className="flex gap-2 overflow-x-auto pb-1">
          {kids.map((k) => (
            <button
              key={k.id}
              className={cls('shrink-0 rounded-full border px-3 py-1 text-sm', activeKidId === k.id && 'bg-black text-white')}
              onClick={() => setActiveKidId(k.id)}
            >
              {k.name || '(unnamed)'}
            </button>
          ))}
        </div>

        <div className="grid gap-3">
          {kids.length === 0 && <div className="text-sm text-gray-500">No kids yet. Tap “Add child”.</div>}
          {kids.map((k) => (
            <div key={k.id} className={cls('grid gap-3 rounded border p-3', activeKidId === k.id && 'ring-2 ring-black')}>
              <div className="grid items-end gap-2 md:grid-cols-6">
                <label className="grid gap-1">
                  <span className="text-sm text-gray-600">Name</span>
                  <input
                    className="rounded border px-2 py-1"
                    value={k.name || ''}
                    onFocus={(e) => {
                      if (e.currentTarget.value === 'New child') e.currentTarget.value = '';
                    }}
                    onChange={(e) => updateKid(k.id, { name: e.target.value })}
                  />
                </label>
                <label className="grid gap-1">
                  <span className="text-sm text-gray-600">Map to API Child</span>
                  <select
                    className="rounded border px-2 py-1"
                    value={k.apiUserId || ''}
                    onChange={(e) => updateKid(k.id, { apiUserId: e.target.value || undefined })}
                  >
                    <option value="">(auto choose first Child)</option>
                    {childUsers.map((u) => (
                      <option key={u.id} value={u.id}>
                        {u.name} ({u.id})
                      </option>
                    ))}
                  </select>
                </label>
                <label className="grid gap-1">
                  <span className="text-sm text-gray-600">Device IP</span>
                  <input
                    className="rounded border px-2 py-1"
                    placeholder="192.168.1.42"
                    value={k.ip || ''}
                    onChange={(e) => updateKid(k.id, { ip: e.target.value })}
                  />
                </label>
                <label className="grid gap-1">
                  <span className="text-sm text-gray-600">Port</span>
                  <input
                    type="number"
                    className="rounded border px-2 py-1"
                    placeholder="8088"
                    value={k.port ?? ''}
                    onChange={(e) => updateKid(k.id, { port: e.target.value ? parseInt(e.target.value, 10) : undefined })}
                  />
                </label>
                <label className="grid gap-1">
                  <span className="text-sm text-gray-600">Auto/Manual</span>
                  <select
                    className="rounded border px-2 py-1"
                    value={k.autoEnforce ? 'auto' : 'manual'}
                    onChange={(e) => updateKid(k.id, { autoEnforce: e.target.value === 'auto' })}
                  >
                    <option value="auto">Automatic</option>
                    <option value="manual">Manual only</option>
                  </select>
                </label>
                <label className="grid gap-1">
                  <span className="text-sm text-gray-600">Auto Action</span>
                  <select
                    className="rounded border px-2 py-1"
                    value={k.autoAction || 'screen_lock'}
                    onChange={(e) => updateKid(k.id, { autoAction: e.target.value as ActionV })}
                  >
                    {ACTIONS.map((a) => (
                      <option key={a.v} value={a.v}>
                        {a.label}
                      </option>
                    ))}
                  </select>
                </label>
              </div>

              {/* phones */}
              <div className="grid gap-2">
                <div className="flex items-center justify-between">
                  <div className="text-sm text-gray-600">Phone numbers (up to 5)</div>
                  <button className="rounded border px-2 py-1 text-sm" onClick={() => addKidPhone(k.id)} disabled={(k.phones || []).length >= 5}>
                    Add phone
                  </button>
                </div>
                {(k.phones || []).map((p, i) => (
                  <div key={i} className="flex items-center gap-2">
                    <input
                      className="rounded border px-2 py-1"
                      placeholder="+1 555…"
                      value={p}
                      onChange={(e) => updateKidPhone(k.id, i, e.target.value)}
                    />
                    <button className="rounded border px-2 py-1 text-sm" onClick={() => removeKidPhone(k.id, i)}>
                      Remove
                    </button>
                  </div>
                ))}
                {(k.phones || []).length === 0 && <div className="text-xs text-gray-500">No phones added.</div>}
              </div>

              <div className="flex gap-2">
                <button className="rounded border px-3 py-1" onClick={() => setActiveKidId(k.id)}>
                  Set Active
                </button>
                <button className="rounded border px-3 py-1" onClick={() => removeKid(k.id)}>
                  Delete child
                </button>
              </div>
            </div>
          ))}
        </div>
        <div className="text-xs text-gray-500">
          (Names, IPs, ports, phones are stored <b>locally</b>. Parental actions use the mapped API Child.)
        </div>
      </section>

      {/* Create tasks */}
      <section className="grid gap-3 rounded border p-3">
        <h2 className="font-medium">Create Minor Tasks</h2>

        {/* Select assignees */}
        <div className="grid gap-2">
          <div className="text-sm text-gray-600">
            Select up to {maxKids === 999 ? '∞' : maxKids} {autoSelectActive ? '(auto from Active Kid)' : ''}
          </div>
          {!autoSelectActive && (
            <div className="flex flex-wrap gap-2">
              {kids.map((k) => {
                const on = selectedKidIds.includes(k.id);
                return (
                  <button key={k.id} type="button" onClick={() => toggleKid(k.id)} className={cls('rounded border px-3 py-1', on && 'bg-black text-white')}>
                    {k.name || '(unnamed)'}
                  </button>
                );
              })}
              {kids.length === 0 && <span className="text-xs text-gray-500">Add kids above to assign tasks.</span>}
            </div>
          )}
          <div className="text-xs text-gray-500">
            Selected: {(autoSelectActive && activeKidId) ? 1 : selectedKidIds.length}/{maxKids === 999 ? '∞' : maxKids}
          </div>
        </div>

        {/* Task details */}
        <div className="grid gap-3 md:grid-cols-3">
          <label className="grid gap-1">
            <span className="text-sm text-gray-600">Template (or type custom)</span>
            <input
              className="rounded border px-2 py-1"
              list="task-templates"
              value={template}
              onChange={(e) => {
                setTemplate(e.target.value);
                if (e.target.value) setTitle(e.target.value);
              }}
              placeholder="e.g. Clean room"
            />
            <datalist id="task-templates">{TEMPLATES.map((t) => <option key={t} value={t} />)}</datalist>
          </label>
          <label className="grid gap-1">
            <span className="text-sm text-gray-600">Title</span>
            <input className="rounded border px-2 py-1" value={title} onChange={(e) => setTitle(e.target.value)} />
          </label>
          <label className="grid gap-1">
            <span className="text-sm text-gray-600">Recurrence</span>
            <select className="rounded border px-2 py-1" value={recurrence} onChange={(e) => setRecurrence(e.target.value as any)}>
              <option value="none">One-time (minutes from now)</option>
              <option value="daily">Daily (at time)</option>
              <option value="weekly">Weekly (day &amp; time)</option>
            </select>
          </label>

          {recurrence === 'none' && (
            <label className="grid gap-1">
              <span className="text-sm text-gray-600">Due (minutes from now)</span>
              <input type="number" min={1} className="rounded border px-2 py-1" value={dueMins} onChange={(e) => setDueMins(parseInt(e.target.value || '0', 10))} />
            </label>
          )}
          {(recurrence === 'daily' || recurrence === 'weekly') && (
            <label className="grid gap-1">
              <span className="text-sm text-gray-600">Time</span>
              <input type="time" className="rounded border px-2 py-1" value={timeHHMM} onChange={(e) => setTimeHHMM(e.target.value)} />
            </label>
          )}
          {recurrence === 'weekly' && (
            <label className="grid gap-1">
              <span className="text-sm text-gray-600">Day of week</span>
              <select className="rounded border px-2 py-1" value={weeklyDOW} onChange={(e) => setWeeklyDOW(parseInt(e.target.value, 10))}>
                <option value={0}>Sunday</option>
                <option value={1}>Monday</option>
                <option value={2}>Tuesday</option>
                <option value={3}>Wednesday</option>
                <option value={4}>Thursday</option>
                <option value={5}>Friday</option>
                <option value={6}>Saturday</option>
              </select>
            </label>
          )}
        </div>

        {/* options */}
        <div className="flex flex-wrap items-center gap-4">
          <label className="flex items-center gap-2 text-sm">
            <input type="checkbox" checked={ackRequired} onChange={(e) => setAckRequired(e.target.checked)} /> Ack required
          </label>
          <label className="flex items-center gap-2 text-sm">
            <input type="checkbox" checked={photoProof} onChange={(e) => setPhotoProof(e.target.checked)} /> Photo proof
          </label>
          <label className="flex items-center gap-2 text-sm">
            <input type="checkbox" checked={autoEnforce} onChange={(e) => setAutoEnforce(e.target.checked)} /> Auto enforce on overdue
          </label>
          <label className="flex items-center gap-2 text-sm">
            <span>Auto action</span>
            <select className="rounded border px-2 py-1" value={autoAction} onChange={(e) => setAutoAction(e.target.value as ActionV)}>
              {ACTIONS.map((a) => (
                <option key={a.v} value={a.v}>
                  {a.label}
                </option>
              ))}
            </select>
          </label>
        </div>

        {/* Save / Cancel */}
        <div className="flex gap-2">
          <button
            className="rounded border px-3 py-1"
            onClick={() => void createMinorTasks()}
            disabled={busy || (!autoSelectActive && selectedKidIds.length === 0) || (autoSelectActive && !activeKidId)}
          >
            Save
          </button>
          <button className="rounded border px-3 py-1" onClick={resetForm} disabled={busy}>
            Cancel
          </button>
        </div>
      </section>

      {/* Parental Enforce */}
      <section className="grid gap-2 rounded border p-3">
        <h2 className="font-medium">Parental Enforce</h2>
        <div className="grid gap-3">
          {kids.length === 0 && <div className="text-sm text-gray-500">Add kids above and map them to API Child users.</div>}
          {kids.map((k) => {
            const apiUserId = k.apiUserId || childUsers[0]?.id || '';
            return (
              <div key={k.id} className="grid gap-2 rounded border p-3">
                <div className="font-medium">
                  {k.name || '(unnamed)'}{' '}
                  <span className="text-xs text-gray-500">
                    IP: {k.ip || '-'}:{k.port ?? '-'} • Phones: {(k.phones || []).filter(Boolean).join(', ') || '-'}
                  </span>
                </div>
                <div className="flex flex-wrap gap-2">
                  {ACTIONS.map((a) => (
                    <button key={a.v} className="rounded border px-2 py-1" disabled={!apiUserId} onClick={() => void enforce(apiUserId, a.v, 'Admin')}>
                      {a.label}
                    </button>
                  ))}
                </div>
              </div>
            );
          })}
        </div>
      </section>

      {/* Tasks table */}
      <section className="grid gap-2 rounded border p-3">
        <div className="flex items-center justify-between">
          <h2 className="font-medium">Tasks</h2>
          <button className="rounded border px-3 py-1" onClick={() => void loadAll()}>
            Refresh
          </button>
        </div>
        <div className="overflow-x-auto">
          <table className="min-w-full text-sm">
            <thead>
              <tr className="border-b text-left">
                <th className="py-2 pr-4">Title</th>
                <th className="py-2 pr-4">Assignee</th>
                <th className="py-2 pr-4">Due</th>
                <th className="py-2 pr-4">Minor</th>
                <th className="py-2 pr-4">Ack</th>
                <th className="py-2 pr-4">Proof</th>
                <th className="py-2">Actions</th>
              </tr>
            </thead>
            <tbody>
              {tasks.map((t) => (
                <tr key={t.id} className="border-b">
                  <td className="py-2 pr-4">{t.title}</td>
                  <td className="py-2 pr-4">{t.assignedTo || '-'}</td>
                  <td className="py-2 pr-4">{t.due ? new Date(t.due).toLocaleString() : '-'}</td>
                  <td className="py-2 pr-4">{t.forMinor ? `stage ${t.__minorStage ?? 0}` : '-'}</td>
                  <td className="py-2 pr-4">{t.ackBy || '-'}</td>
                  <td className="py-2 pr-4">{t.proofKey ? t.proofKey.split('/').slice(-1)[0] : '-'}</td>
                  <td className="py-2">
                    <button className="mr-2 rounded border px-2 py-1" onClick={() => void ackTask(t.id)}>
                      Ack
                    </button>
                  </td>
                </tr>
              ))}
              {tasks.length === 0 && (
                <tr>
                  <td className="py-4 text-gray-500" colSpan={7}>
                    No tasks
                  </td>
                </tr>
              )}
            </tbody>
          </table>
        </div>
      </section>

      {/* Phone Previews (local only) */}
      <section className="grid gap-3 rounded border p-3">
        <h2 className="font-medium">Phone Preview</h2>
        <div className="text-xs text-gray-500">Local-only preview (no backend writes). Choose an active kid above.</div>

        {/* Kid phone */}
        <div className="grid gap-2 rounded border p-3">
          <div className="font-medium">Kid Phone</div>
          {!activeKidId && <div className="text-sm text-gray-500">Select an active kid to preview.</div>}
          {!!activeKidId &&
            (() => {
              const kid = kids.find((k) => k.id === activeKidId)!;
              const apiUserId = kid.apiUserId || childUsers[0]?.id || '';
              const assigned = tasks.filter((t) => apiUserId && t.assignedTo === apiUserId);
              const mt = phoneTasks[activeKidId] || [];
              const manualInputId = `kid-manual-title-${activeKidId}`;

              return (
                <div className="grid gap-3">
                  {/* local manual tasks */}
                  <div className="grid gap-2">
                    <label className="grid gap-1">
                      <span className="text-sm text-gray-600">Add Manual Task (local)</span>
                      <div className="flex gap-2">
                        <input id={manualInputId} className="rounded border px-2 py-1 flex-1" placeholder="e.g. Stretch for 5 minutes" />
                        <button
                          className="rounded border px-3 py-1"
                          onClick={() => {
                            const el = document.getElementById(manualInputId) as HTMLInputElement | null;
                            const val = el?.value?.trim();
                            if (!val) return;
                            const entry = { id: `local-${Date.now()}`, title: val };
                            const next = { ...phoneTasks, [activeKidId]: [...mt, entry] };
                            try {
                              localStorage.setItem(LSK_LOCAL_PHONE_TASKS, JSON.stringify(next));
                            } catch {}
                            setPhoneTasks(next);
                            if (el) el.value = '';
                          }}
                        >
                          Add
                        </button>
                      </div>
                    </label>
                    {mt.length > 0 && (
                      <div className="grid gap-1">
                        <div className="text-xs text-gray-600">Local tasks</div>
                        {mt.map((m) => (
                          <div key={m.id} className="flex items-center justify-between rounded border px-2 py-1">
                            <span className="text-sm">{m.title}</span>
                            <button
                              className="rounded border px-2 py-0.5 text-xs"
                              onClick={() => {
                                const next = { ...phoneTasks, [activeKidId]: mt.filter((x) => x.id !== m.id) };
                                try {
                                  localStorage.setItem(LSK_LOCAL_PHONE_TASKS, JSON.stringify(next));
                                } catch {}
                                setPhoneTasks(next);
                              }}
                            >
                              Remove
                            </button>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>

                  {/* assigned tasks */}
                  <div className="grid gap-2">
                    <div className="text-sm text-gray-600">Assigned Tasks (API)</div>
                    {assigned.length === 0 && <div className="text-xs text-gray-500">No assigned tasks.</div>}
                    {assigned.map((t) => {
                      const note = taskNotes[t.id] || { status: 'not_started' as KidStatus, comment: '' };
                      return (
                        <div key={t.id} className="grid gap-2 rounded border p-2">
                          <div className="flex items-center justify-between">
                            <div className="text-sm font-medium">{t.title}</div>
                            <div className="text-xs text-gray-500">{t.due ? new Date(t.due).toLocaleString() : '-'}</div>
                          </div>
                          <div className="grid gap-2 sm:flex sm:items-center sm:gap-3">
                            <label className="flex items-center gap-2 text-sm">
                              <span>Status</span>
                              <select
                                className="rounded border px-2 py-1"
                                value={note.status}
                                onChange={(e) => {
                                  const next = { ...taskNotes, [t.id]: { ...note, status: e.target.value as KidStatus } };
                                  persistTaskNotes(next);
                                }}
                              >
                                <option value="not_started">Not started</option>
                                <option value="in_progress">In progress</option>
                                <option value="almost_done">Almost done</option>
                                <option value="done">Done</option>
                                <option value="skipped">Skipped</option>
                              </select>
                            </label>
                            <button className="rounded border px-2 py-1 text-sm" onClick={() => void ackTask(t.id)}>
                              Acknowledge
                            </button>
                          </div>
                          <label className="grid gap-1">
                            <span className="text-sm">Comment</span>
                            <textarea
                              className="rounded border px-2 py-1"
                              rows={2}
                              placeholder="I'm feeling sick…"
                              value={note.comment || ''}
                              onChange={(e) => {
                                const next = { ...taskNotes, [t.id]: { ...note, comment: e.target.value } };
                                persistTaskNotes(next);
                              }}
                            />
                          </label>
                        </div>
                      );
                    })}
                  </div>
                </div>
              );
            })()}
        </div>

        {/* Owner preview */}
        <div className="grid gap-2 rounded border p-3">
          <div className="font-medium">Owner Preview</div>
          {!activeKidId && <div className="text-sm text-gray-500">Select an active kid to preview.</div>}
          {!!activeKidId &&
            (() => {
              const kid = kids.find((k) => k.id === activeKidId)!;
              const apiUserId = kid.apiUserId || childUsers[0]?.id || '';
              const assigned = tasks.filter((t) => apiUserId && t.assignedTo === apiUserId);
              return (
                <div className="grid gap-2">
                  {assigned.map((t) => {
                    const note = ownerNotes[t.id] || { preset: '', comment: '' };
                    return (
                      <div key={t.id} className="grid gap-2 rounded border p-2">
                        <div className="text-sm font-medium">{t.title}</div>
                        <div className="grid gap-2 sm:flex sm:items-center sm:gap-3">
                          <label className="flex items-center gap-2 text-sm">
                            <span>Quick comment</span>
                            <select
                              className="rounded border px-2 py-1"
                              value={note.preset || ''}
                              onChange={(e) => {
                                const next = { ...ownerNotes, [t.id]: { ...note, preset: e.target.value } };
                                persistOwnerNotes(next);
                              }}
                            >
                              <option value="">(none)</option>
                              <option value="good_job">Good job!</option>
                              <option value="please_finish">Please finish soon</option>
                              <option value="almost_there">Almost there—keep going</option>
                              <option value="need_help">Need help?</option>
                            </select>
                          </label>
                        </div>
                        <label className="grid gap-1">
                          <span className="text-sm">Message</span>
                          <textarea
                            className="rounded border px-2 py-1"
                            rows={2}
                            placeholder="Proud of you for sticking with it!"
                            value={note.comment || ''}
                            onChange={(e) => {
                              const next = { ...ownerNotes, [t.id]: { ...note, comment: e.target.value } };
                              persistOwnerNotes(next);
                            }}
                          />
                        </label>
                        <div className="text-xs text-gray-500">Saved locally (no server endpoint yet).</div>
                      </div>
                    );
                  })}
                  {assigned.length === 0 && <div className="text-xs text-gray-500">No assigned tasks to comment on.</div>}
                </div>
              );
            })()}
        </div>
      </section>

      <footer className="text-xs text-gray-500">
        Connected to API at {API_BASE} as <b>{acting}</b>
      </footer>
    </div>
  );
}
